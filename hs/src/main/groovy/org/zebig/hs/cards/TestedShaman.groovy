package org.zebig.hs.cardsimport org.zebig.hs.game.Cardimport org.zebig.hs.game.CardDefinitionimport org.zebig.hs.game.Gameimport org.zebig.hs.game.Targetimport static org.zebig.hs.mechanics.buffs.BuffType.*class AlAkirTheWindlord extends CardDefinition {    AlAkirTheWindlord(Game game) {        super(game)        name = "Al'Akir the Windlord"; type = 'minion'; cost = 8; attack = 3; max_health = 5        text = 'Windfury, Charge, Divine Shield, Taunt'        reserved_to = "Shaman"        when_coming_in_play(text) {            this_minion.gains(WINDFURY)            this_minion.gains(CHARGE)            this_minion.gains(DIVINE_SHIELD)            this_minion.gains(TAUNT)        }    }}class AncestralHealing extends CardDefinition {    AncestralHealing(Game game) {        super(game)        name = 'Ancestral Healing'; type = 'spell'; cost = 0        text = 'Restore a minion to full Health and give it Taunt.'        reserved_to = "Shaman"        get_targets = [{ all_minion_targets }]        when_played(text) {            def m = select_spell_target(all_minion_targets)            m.set_health(m.max_health)            m.gains(TAUNT)        }    }}class AncestralSpirit extends CardDefinition {    AncestralSpirit(Game game) {        super(game)        name = 'Ancestral Spirit'; type = 'spell'; cost = 2        text = 'Choose a minion. When that minion is destroyed, return it to the battlefield'        reserved_to = "Shaman"        get_targets = [{ all_minion_targets }]        when_played(text) {            def m = select_spell_target(all_minion_targets)            m.gains(RETURN_TO_BATTLEFIELD_WHEN_DESTROYED)        }    }}class Bloodlust extends CardDefinition {    Bloodlust(Game game) {        super(game)        name = 'Bloodlust'; type = 'spell'; cost = 5        text = 'Give your minions +3 Attack this turn.'        reserved_to = "Shaman"        when_played(text) {            your_minions.each { it.gains('+3 Attack').until_end_of_turn() }        }    }}class Doomhammer extends CardDefinition {    Doomhammer(Game game) {        super(game)        name = 'Doomhammer'; type = 'weapon'; cost = 5; attack = 2; max_health = 8        text = 'Windfury, Overload: (2)'        reserved_to = "Shaman"        when_coming_in_play('Windfury') { this_weapon.gains(WINDFURY) }        when_played('Overload: (2)') { you.add_overload(2) }    }}class DustDevil extends CardDefinition {    DustDevil(Game game) {        super(game)        name = 'Dust Devil'; type = 'minion'; cost = 1; attack = 3; max_health = 1        text = 'Windfury. Overload: (2)'        reserved_to = "Shaman"        when_coming_in_play('Windfury') { this_minion.gains(WINDFURY) }        when_played('Overload: (2)') { you.add_overload(2) }    }}class EarthElemental extends CardDefinition {    EarthElemental(Game game) {        super(game)        name = 'Earth Elemental'; type = 'minion'; cost = 5; attack = 7; max_health = 8        text = 'Taunt. Overload: (3).'        reserved_to = "Shaman"        when_coming_in_play('Taunt') { this_minion.gains(TAUNT) }        when_played('Overload: (3)') { you.add_overload(3) }    }}class EarthShock extends CardDefinition {    EarthShock(Game game) {        super(game)        name = 'Earth Shock'; type = 'spell'; cost = 1        text = 'Silence a minion, then deal 1 damage to it.'        reserved_to = "Shaman"        get_targets = [{ all_minion_targets }]        when_played(text) {            def m = select_spell_target(all_minion_targets)            this_spell.silence(m)            this_spell.deal_spell_damage(1, m)        }    }}class FarSight extends CardDefinition {    FarSight(Game game) {        super(game)        name = 'Far Sight'; type = 'spell'; cost = 3        text = 'Draw a card. That card costs (3) less.'        reserved_to = "Shaman"        before_play("check deck size") {            check(you.deck.size() > 0, 'your deck is empty')        }        when_played(text) {            List<Card> lc = you.draw(1)            if (lc.size() > 0) {                lc.get(0).gains('costs (3) less')            }        }    }}class FeralSpirit extends CardDefinition {    FeralSpirit(Game game) {        super(game)        name = 'Feral Spirit'; type = 'spell'; cost = 3        text = 'Summon two 2/3 Spirit Wolves with Taunt. Overload: (2)'        reserved_to = "Shaman"        when_played(text) {            game.summon(you, "Spirit Wolf")            game.summon(you, "Spirit Wolf")            you.add_overload(2)        }    }}class FireElemental extends CardDefinition {    FireElemental(Game game) {        super(game)        name = 'Fire Elemental'; type = 'minion'; cost = 6; attack = 6; max_health = 5        text = 'Battlecry: Deal 3 damage'        reserved_to = "Shaman"        get_targets = [{ all_targets }]        when_played(text) {            this_minion.deal_damage(3, select_target(all_targets))        }    }}class FlametongueTotem extends CardDefinition {    FlametongueTotem(Game game) {        super(game)        name = 'Flametongue Totem'; type = 'minion'; creature_type = 'totem'; cost = 2; attack = 0; max_health = 3        text = 'Adjacent minions have +2 Attack.'        reserved_to = "Shaman"        when_coming_in_play(text) {            def flt = this_minion            flt.when_attack_is_evaluated("check $text") {                if (that_target.is_a_minion() && that_minion.controller == flt.controller) {                    if (that_minion.place == flt.place + 1 || that_minion.place == flt.place - 1) {                        attack_increase += 2                    }                }            }        }    }}class ForkedLightning extends CardDefinition {    ForkedLightning(Game game) {        super(game)        name = 'Forked Lightning'; type = 'spell'; cost = 1        text = 'Deal 2 damage to 2 random enemy minions. Overload: (2)'        reserved_to = "Shaman"        before_play("check targets") {            check(opponent.board.size() >= 2, 'not enough targets')        }        when_played(text) {            def choose_from = enemy_minions            2.times {                Collections.shuffle(choose_from)                def chosen = choose_from.remove(0)                this_spell.deal_spell_damage(2, chosen)            }            you.add_overload(2)        }    }}class Frog extends CardDefinition {    Frog(Game game) {        super(game)        name = 'Frog'; type = 'minion'; creature_type = "beast"; cost = 0; attack = 0; max_health = 1        text = 'Taunt'        collectible = false        when_coming_in_play(text) {            this_minion.gains(TAUNT)        }    }}class FrostShock extends CardDefinition {    FrostShock(Game game) {        super(game)        name = 'Frost Shock'; type = 'spell'; cost = 1        text = 'Deal 1 damage to an enemy character and Freeze it.'        reserved_to = "Shaman"        get_targets = [{ enemy_minion_targets + opponent_hero }]        when_played(text) {            def t = select_spell_target(enemy_minion_targets + opponent_hero)            this_spell.deal_spell_damage(1, t)            this_spell.freeze(t)        }    }}class HealingTotem extends CardDefinition {    HealingTotem(Game game) {        super(game)        name = 'Healing Totem'; type = 'minion'; creature_type = 'totem'; cost = 1; attack = 0; max_health = 2        text = 'At the end of your turn, restore 1 Health to all friendly minions.'        reserved_to = "Shaman"        when_coming_in_play(text) {            def healing_totem = this_minion            healing_totem.when_its_controller_turn_ends(text) {                healing_totem.restore_health(1, healing_totem.controller.minions())            }        }    }}class Hex extends CardDefinition {    Hex(Game game) {        super(game)        name = 'Hex'; type = 'spell'; cost = 3        text = 'Transform a minion into a 0/1 Frog with Taunt'        reserved_to = "Shaman"        get_targets = [{ all_minion_targets }]        when_played(text) {            Target t = select_spell_target(all_minion_targets)            game.transform(t as Card, "Frog")        }    }}class LavaBurst extends CardDefinition {    LavaBurst(Game game) {        super(game)        name = 'Lava Burst'; type = 'spell'; cost = 3        text = 'Deal 5 damage. Overload: (2)'        reserved_to = "Shaman"        get_targets = [{ all_targets }]        when_played(text) {            this_spell.deal_spell_damage(5, select_spell_target(all_targets))            you.add_overload(2)        }    }}class LightningBolt extends CardDefinition {    LightningBolt(Game game) {        super(game)        name = 'Lightning Bolt'; type = 'spell'; cost = 1        text = 'Deal 3 damage. Overload: (1)'        reserved_to = "Shaman"        get_targets = [{ all_targets }]        when_played(text) {            this_spell.deal_spell_damage(3, select_spell_target(all_targets))            you.add_overload(1)        }    }}class LightningStorm extends CardDefinition {    LightningStorm(Game game) {        super(game)        name = 'Lightning Storm'; type = 'spell'; cost = 3        text = 'Deal 2-3 damage to all enemy minions. Overload: (2)'        reserved_to = "Shaman"        when_played(text) {            enemy_minions.each {                this_spell.deal_spell_damage(2 + game.get_random_int(2), it)            }            you.add_overload(2)        }    }}class ManaTideTotem extends CardDefinition {    ManaTideTotem(Game game) {        super(game)        name = 'Mana Tide Totem'; type = 'minion'; creature_type = 'totem'; cost = 3; attack = 0; max_health = 3        text = "At the end of your turn, draw a card."        reserved_to = "Shaman"        when_coming_in_play(text) {            def mtt = this_minion            this_minion.when_its_controller_turn_ends(text) {                mtt.controller.draw(1)            }        }    }}class Reincarnate extends CardDefinition {    Reincarnate(Game game) {        super(game)        name = 'Reincarnate'; type = 'spell'; cost = 2        text = 'Destroy a minion, then return it to life with full Health.'        reserved_to = "Shaman"        get_targets = [{ all_minion_targets }]        when_played(text) {            Card _m = select_spell_target(all_minion_targets)            this_spell.destroy(_m)            game.summon(_m.controller, _m.name)        }    }}class RockbiterWeapon extends CardDefinition {    RockbiterWeapon(Game game) {        super(game)        name = 'Rockbiter Weapon'; type = 'spell'; cost = 1        text = 'Give a friendly character +3 Attack this turn.'        reserved_to = "Shaman"        get_targets = [{ your_minion_targets + your_hero }]        when_played(text) {            def friendly_characters = your_minion_targets + your_hero            select_spell_target(friendly_characters).gains('+3 Attack').until_end_of_turn()        }    }}class SearingTotem extends CardDefinition {    SearingTotem(Game game) {        super(game)        name = 'Searing Totem'; type = 'minion'; creature_type = 'totem'; cost = 1; attack = 1; max_health = 1        collectible = false        reserved_to = "Shaman"    }}class SpiritWolf extends CardDefinition {    SpiritWolf(Game game) {        super(game)        name = "Spirit Wolf"; type = "minion"; cost = 2; attack = 2; max_health = 3        text = 'Taunt'        collectible = false        reserved_to = "Shaman"        when_coming_in_play(text) { this_minion.gains(TAUNT) }    }}class StoneclawTotem extends CardDefinition {    StoneclawTotem(Game game) {        super(game)        name = 'Stoneclaw Totem'; type = 'minion'; creature_type = 'totem'; cost = 1; attack = 0; max_health = 2        text = 'Taunt'        reserved_to = "Shaman"        when_coming_in_play(text) {            this_minion.gains(TAUNT)        }    }}class StormforgedAxe extends CardDefinition {    StormforgedAxe(Game game) {        super(game)        name = 'Stormforged Axe'; type = 'weapon'; cost = 2; attack = 2; max_health = 3        text = 'Overload: (1)'        reserved_to = "Shaman"        when_played(text) {            you.add_overload(1)        }    }}class TotemicMight extends CardDefinition {    TotemicMight(Game game) {        super(game)        name = 'Totemic Might'; type = 'spell'; cost = 0        text = 'Give your Totems +2 Health.'        reserved_to = "Shaman"        when_played(text) {            List<Card> your_totems = your_minions.findAll { it.is_a_totem() }            your_totems*.gains('+2 Health')        }    }}class UnboundElemental extends CardDefinition {    UnboundElemental(Game game) {        super(game)        name = 'Unbound Elemental'; type = 'minion'; cost = 3; attack = 2; max_health = 4        text = 'Whenever you play a card with Overload, gain +1/+1.'        reserved_to = "Shaman"        when_coming_in_play("add $text") {            def _unbound_elem = this_minion            _unbound_elem.when_its_controller_plays_a_card("check $text") {                def matcher = that_card.text =~ /.*Overload: \(\d+\).*/                if (matcher.matches()) {                    _unbound_elem.gains('+1/+1')                }            }        }    }}class Windfury extends CardDefinition {    Windfury(Game game) {        super(game)        name = 'Windfury'; type = 'spell'; cost = 2        text = 'Give a minion Windfury.'        reserved_to = "Shaman"        get_targets = [{ all_minion_targets }]        when_played(text) {            select_spell_target(all_minion_targets)?.gains(WINDFURY)        }    }}class Windspeaker extends CardDefinition {    Windspeaker(Game game) {        super(game)        name = 'Windspeaker'; type = 'minion'; cost = 4; attack = 3; max_health = 3        text = 'Battlecry: Give a friendly minion Windfury.'        reserved_to = "Shaman"        get_targets = [{ your_minions }]        when_played(text) {            if (your_board.size() > 0) {                select_target(your_minions)?.gains(WINDFURY)            }        }    }}class WrathOfAirTotem extends CardDefinition {    WrathOfAirTotem(Game game) {        super(game)        name = 'Wrath of Air Totem'; type = 'minion'; creature_type = 'totem'; cost = 1; attack = 0; max_health = 2        text = 'Spell Damage +1'        reserved_to = "Shaman"        when_coming_in_play(text) {            this_minion.gains("Spell Damage +1")        }    }}